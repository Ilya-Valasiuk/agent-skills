---
description: "Standards for Next.js Server Actions: folder structure, naming, error handling, and relationship with the API layer."
alwaysApply: false
---
# Server Actions

> **Scope**: Apply when creating or modifying Server Actions in `src/actions/`.
> **Not** the same as `src/api/` — see [Relationship with API Layer](#5-relationship-with-api-layer).

Server Actions are asynchronous functions that run on the server, invoked directly from React components (forms, event handlers). They use the `'use server'` directive and are the standard way to handle **mutations** in Next.js App Router.

Reference: https://nextjs.org/docs/app/getting-started/updating-data

## 1. Directory Structure

```
src/actions/
├── [domain-name]/
│   ├── index.ts           # Server Action functions (entry point)
│   ├── types.ts           # Action-specific types (optional)
│   ├── helpers.ts         # Helper functions (optional)
│   └── constants.ts       # Domain constants (optional)
```

- Organize by domain (e.g., `contact`, `product`, `auth`)
- Each domain folder mirrors the same optional-file pattern as `src/api/[domain]/`

## 2. File Conventions

### index.ts

Every `index.ts` must start with the `'use server'` directive at the **top of the file** (module-level). This marks all exported functions as Server Actions.

```typescript
'use server';

import { revalidatePath } from 'next/cache';

export const createProduct = async (
  prevState: ActionState,
  payload: CreateProductPayload,
) => {
  try {
    // Perform mutation (e.g., call API fetcher, send email, etc.)
    // Revalidate cache if needed
    revalidatePath('/products');

    return { ...prevState, error: null, success: true };
  } catch {
    return { ...prevState, error: 'Failed to create product', success: false };
  }
};
```

### types.ts

Action-specific types only. Domain entity types belong in `src/api/[domain]/types.ts`.

```typescript
export type ActionState = {
  error: string | null;
  success: boolean;
};
```

### helpers.ts

Pure helper functions used only within this action domain. Must **not** contain the `'use server'` directive.

## 3. Naming Conventions

- **Action functions**: Use descriptive verb matching the mutation — `createProduct`, `deletePost`, `contactUs`, `validateReCaptcha`
- **Suffix with `Action`** when the name would conflict with an API fetcher — e.g., `createProductAction` (action) vs `createProduct` (fetcher in `src/api/`)
- **Files**: `index.ts` for main exports, `types.ts`, `helpers.ts` (same pattern as API modules)

## 4. Patterns

### Return Type for `useActionState`

When an action is used with React's `useActionState`, follow this signature:

```typescript
export const myAction = async (
  prevState: { error: string | null; success: boolean },
  payload: MyPayload,
) => {
  try {
    // ... mutation logic
    return { ...prevState, error: null, success: true };
  } catch {
    return { ...prevState, error: 'Descriptive error message', success: false };
  }
};
```

### Cache Revalidation

After a successful mutation, revalidate relevant cache:

```typescript
import { revalidatePath } from 'next/cache';
import { revalidateTag } from 'next/cache';

// Revalidate a specific path
revalidatePath('/products');

// Or revalidate by cache tag
revalidateTag('products');
```

### Redirecting

Call `redirect` **after** `revalidatePath`/`revalidateTag` — code after `redirect` does not execute:

```typescript
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

export const createProduct = async (prevState: ActionState, payload: CreateProductPayload) => {
  'use server';

  // ... mutation
  revalidatePath('/products');
  redirect('/products');
};
```

### Error Handling

- Always wrap mutation logic in `try/catch`
- Return a user-friendly error message — never expose raw error details to the client
- Log detailed errors server-side with `console.error`

## 5. Relationship with API Layer

Server Actions (`src/actions/`) and the API module (`src/api/`) are **separate layers**:

| | `src/api/` | `src/actions/` |
|---|---|---|
| Purpose | Data fetching (read) | Mutations from UI (write) |
| Directive | None | `'use server'` required |
| Invoked by | React Query hooks, Server Components | Forms, event handlers (`useActionState`) |
| Returns | Typed API response data | UI state (`{ error, success }`) |

**Key rules:**
- Actions **may import** fetchers from `src/api/` to perform HTTP mutations
- `src/api/` must **never import** from `src/actions/`
- Keep pure HTTP logic in `src/api/`, keep orchestration (validation, caching, error handling) in `src/actions/`

```typescript
// Good: action calls API fetcher
'use server';

import { createProduct } from '@/api/product/module';

export const createProductAction = async (prevState: ActionState, payload: CreateProductPayload) => {
  try {
    await createProduct(payload);
    return { ...prevState, error: null, success: true };
  } catch {
    return { ...prevState, error: 'Failed to create product', success: false };
  }
};
```

## 6. When to Use Server Actions vs Route Handlers

- **Server Actions** (`src/actions/`) — mutations triggered by your own React UI (forms, buttons)
- **Route Handlers** (`src/app/api/`) — HTTP endpoints callable by external systems (webhooks, 3rd-party services, mobile apps)
